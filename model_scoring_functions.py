#!/usr/bin/env python3
"""
Bank Credit Risk Scoring Model - Scoring Functions

Purpose: Provide scoring functions that replicate tree_model.sas functionality
Author: Risk Analytics Team
Date: 2025

This script contains Python functions that replicate the exact scoring logic
from the SAS-generated tree_model.sas file (PROC HPSPLIT output).

MIGRATION FROM SAS:
This Python implementation replicates the exact decision tree scoring logic
generated by PROC HPSPLIT, maintaining identical decision rules and
probability assignments.

USAGE:
    from model_scoring_functions import score_with_decision_tree
    
    predictions = score_with_decision_tree(data)

INPUT:
    - DataFrame with required features for tree scoring
    - Features: credit_score, total_risk_flags, monthly_income, 
               debt_to_income_ratio, emp_unemployed, credit_utilization

OUTPUT:
    - DataFrame with tree predictions and node assignments
    - Probabilities for default_flag=1 and default_flag=0
    - Leaf assignments and node numbers

DEPENDENCIES:
    - pandas>=1.5.0
    - numpy>=1.24.0
"""

import numpy as np
import pandas as pd
import joblib
from pathlib import Path
import warnings

warnings.filterwarnings('ignore')

def score_with_decision_tree(data):
    """
    Score data using the decision tree rules from tree_model.sas.
    
    This function replicates the exact decision tree logic generated by
    PROC HPSPLIT in the original SAS implementation.
    
    Args:
        data (pd.DataFrame): Input data with required features
        
    Returns:
        pd.DataFrame: Data with tree scoring results
    """
    df = data.copy()
    
    # Initialize output variables
    df['_Node_'] = 0
    df['_Leaf_'] = 0
    df['_WARN_'] = ''
    df['P_default_flag1'] = 0.0
    df['P_default_flag0'] = 0.0
    df['V_default_flag1'] = 0.0
    df['V_default_flag0'] = 0.0
    
    # Apply the exact decision tree logic from tree_model.sas
    for idx, row in df.iterrows():
        credit_score = row.get('credit_score', np.nan)
        total_risk_flags = row.get('total_risk_flags', np.nan)
        monthly_income = row.get('monthly_income', np.nan)
        debt_to_income_ratio = row.get('debt_to_income_ratio', np.nan)
        emp_unemployed = row.get('emp_unemployed', np.nan)
        credit_utilization = row.get('credit_utilization', np.nan)
        
        # Main decision tree logic (replicating tree_model.sas exactly)
        if not pd.isna(credit_score) and credit_score < 608.37:
            if not pd.isna(credit_score) and credit_score < 456.89:
                # Node 3
                df.loc[idx, '_Node_'] = 3
                df.loc[idx, '_Leaf_'] = 0
                df.loc[idx, 'P_default_flag1'] = 0.72222222
                df.loc[idx, 'P_default_flag0'] = 0.27777778
                df.loc[idx, 'V_default_flag1'] = 0.62962963
                df.loc[idx, 'V_default_flag0'] = 0.37037037
            else:
                if not pd.isna(total_risk_flags) and total_risk_flags >= 2.04:
                    if not pd.isna(monthly_income) and monthly_income < -0.8362282325677504:
                        # Node 13
                        df.loc[idx, '_Node_'] = 13
                        df.loc[idx, '_Leaf_'] = 4
                        df.loc[idx, 'P_default_flag1'] = 0.76923077
                        df.loc[idx, 'P_default_flag0'] = 0.23076923
                        df.loc[idx, 'V_default_flag1'] = 0.5
                        df.loc[idx, 'V_default_flag0'] = 0.5
                    else:
                        # Node 14
                        df.loc[idx, '_Node_'] = 14
                        df.loc[idx, '_Leaf_'] = 5
                        df.loc[idx, 'P_default_flag1'] = 0.46099291
                        df.loc[idx, 'P_default_flag0'] = 0.53900709
                        df.loc[idx, 'V_default_flag1'] = 0.44444444
                        df.loc[idx, 'V_default_flag0'] = 0.55555556
                else:
                    if not pd.isna(credit_score) and credit_score >= 581.32:
                        # Node 12
                        df.loc[idx, '_Node_'] = 12
                        df.loc[idx, '_Leaf_'] = 3
                        df.loc[idx, 'P_default_flag1'] = 0.27722772
                        df.loc[idx, 'P_default_flag0'] = 0.72277228
                        df.loc[idx, 'V_default_flag1'] = 0.38356164
                        df.loc[idx, 'V_default_flag0'] = 0.61643836
                    else:
                        if not pd.isna(debt_to_income_ratio) and debt_to_income_ratio < -0.2764993696502716:
                            # Node 17
                            df.loc[idx, '_Node_'] = 17
                            df.loc[idx, '_Leaf_'] = 7
                            df.loc[idx, 'P_default_flag1'] = 0.33333333
                            df.loc[idx, 'P_default_flag0'] = 0.66666667
                            df.loc[idx, 'V_default_flag1'] = 0.34545455
                            df.loc[idx, 'V_default_flag0'] = 0.65454545
                        else:
                            if not pd.isna(debt_to_income_ratio) and debt_to_income_ratio >= 2.725590185734137:
                                # Node 22
                                df.loc[idx, '_Node_'] = 22
                                df.loc[idx, '_Leaf_'] = 11
                                df.loc[idx, 'P_default_flag1'] = 0
                                df.loc[idx, 'P_default_flag0'] = 1
                                df.loc[idx, 'V_default_flag1'] = 1
                                df.loc[idx, 'V_default_flag0'] = 0
                            else:
                                # Node 21
                                df.loc[idx, '_Node_'] = 21
                                df.loc[idx, '_Leaf_'] = 10
                                df.loc[idx, 'P_default_flag1'] = 0.5
                                df.loc[idx, 'P_default_flag0'] = 0.5
                                df.loc[idx, 'V_default_flag1'] = 0.55932203
                                df.loc[idx, 'V_default_flag0'] = 0.44067797
        else:
            # Credit score >= 608.37 or missing
            if not pd.isna(debt_to_income_ratio) and debt_to_income_ratio < -1.012860958706825:
                # Node 5
                df.loc[idx, '_Node_'] = 5
                df.loc[idx, '_Leaf_'] = 1
                df.loc[idx, 'P_default_flag1'] = 0.083979328
                df.loc[idx, 'P_default_flag0'] = 0.91602067
                df.loc[idx, 'V_default_flag1'] = 0.12140575
                df.loc[idx, 'V_default_flag0'] = 0.87859425
            else:
                if not pd.isna(credit_score) and credit_score >= 694.93:
                    # Node 10
                    df.loc[idx, '_Node_'] = 10
                    df.loc[idx, '_Leaf_'] = 2
                    df.loc[idx, 'P_default_flag1'] = 0.15973478
                    df.loc[idx, 'P_default_flag0'] = 0.84026522
                    df.loc[idx, 'V_default_flag1'] = 0.1669024
                    df.loc[idx, 'V_default_flag0'] = 0.8330976
                else:
                    if not pd.isna(emp_unemployed) and emp_unemployed == 1:
                        if not pd.isna(credit_utilization) and credit_utilization < -0.6558261628423244:
                            # Node 19
                            df.loc[idx, '_Node_'] = 19
                            df.loc[idx, '_Leaf_'] = 8
                            df.loc[idx, 'P_default_flag1'] = 0.75
                            df.loc[idx, 'P_default_flag0'] = 0.25
                            df.loc[idx, 'V_default_flag1'] = 0.44444444
                            df.loc[idx, 'V_default_flag0'] = 0.55555556
                        else:
                            # Node 20
                            df.loc[idx, '_Node_'] = 20
                            df.loc[idx, '_Leaf_'] = 9
                            df.loc[idx, 'P_default_flag1'] = 0.39393939
                            df.loc[idx, 'P_default_flag0'] = 0.60606061
                            df.loc[idx, 'V_default_flag1'] = 0.41935484
                            df.loc[idx, 'V_default_flag0'] = 0.58064516
                    else:
                        # Node 16
                        df.loc[idx, '_Node_'] = 16
                        df.loc[idx, '_Leaf_'] = 6
                        df.loc[idx, 'P_default_flag1'] = 0.2288383
                        df.loc[idx, 'P_default_flag0'] = 0.7711617
                        df.loc[idx, 'V_default_flag1'] = 0.23796791
                        df.loc[idx, 'V_default_flag0'] = 0.76203209
    
    return df

def load_saved_models():
    """
    Load saved models for scoring.
    
    Returns:
        dict: Dictionary containing loaded models
    """
    models_dir = Path('models')
    
    try:
        models = {}
        
        # Load logistic regression model
        lr_path = models_dir / 'logistic_model.joblib'
        if lr_path.exists():
            models['logistic'] = joblib.load(lr_path)
            print("✓ Logistic regression model loaded")
        
        # Load decision tree model
        dt_path = models_dir / 'decision_tree_model.joblib'
        if dt_path.exists():
            models['decision_tree'] = joblib.load(dt_path)
            print("✓ Decision tree model loaded")
        
        # Load calibrated model
        cal_path = models_dir / 'calibrated_model.joblib'
        if cal_path.exists():
            models['calibrated'] = joblib.load(cal_path)
            print("✓ Calibrated model loaded")
        
        return models
        
    except Exception as e:
        print(f"❌ Error loading models: {str(e)}")
        return {}

def score_with_logistic_regression(data, models):
    """
    Score data using the trained logistic regression model.
    
    Args:
        data (pd.DataFrame): Input data
        models (dict): Loaded models dictionary
        
    Returns:
        np.array: Probability predictions
    """
    try:
        if 'logistic' not in models:
            raise Exception("Logistic regression model not found")
        
        lr_model = models['logistic']
        
        # Prepare features (use same features as training)
        X = data[lr_model['selected_features']].copy()
        
        # Handle missing values
        for col in X.columns:
            if X[col].dtype in ['float64', 'int64']:
                X[col] = X[col].fillna(X[col].median())
            else:
                X[col] = X[col].fillna(0)
        
        # Apply feature selection
        X_selected = lr_model['selector'].transform(X)
        
        # Generate predictions
        predictions = lr_model['model'].predict_proba(X_selected)[:, 1]
        
        return predictions
        
    except Exception as e:
        print(f"❌ Error scoring with logistic regression: {str(e)}")
        return np.zeros(len(data))

def score_with_sklearn_decision_tree(data, models):
    """
    Score data using the trained sklearn decision tree model.
    
    Args:
        data (pd.DataFrame): Input data
        models (dict): Loaded models dictionary
        
    Returns:
        np.array: Probability predictions
    """
    try:
        if 'decision_tree' not in models:
            raise Exception("Decision tree model not found")
        
        dt_model = models['decision_tree']['model']
        
        # Prepare features matching the training feature set
        required_features = [
            'credit_score', 'debt_to_income_ratio', 'credit_utilization',
            'payment_to_income_ratio', 'loan_to_income_ratio',
            'employment_years', 'employment_score', 'num_late_payments',
            'previous_defaults', 'has_delinquency', 'credit_quality_score',
            'credit_history_years', 'flag_high_dti', 'flag_low_credit',
            'flag_high_util', 'flag_recent_default', 'total_risk_flags',
            'age', 'monthly_income', 'loan_amount', 'affordability_score',
            'emp_fulltime', 'emp_unemployed', 'home_rent', 'purpose_debt'
        ]
        
        # Keep only available features
        available_features = [f for f in required_features if f in data.columns]
        X = data[available_features].copy()
        
        # Handle missing values
        for col in X.columns:
            if X[col].dtype in ['float64', 'int64']:
                X[col] = X[col].fillna(X[col].median())
            else:
                X[col] = X[col].fillna(0)
        
        # Generate predictions
        predictions = dt_model.predict_proba(X)[:, 1]
        
        return predictions
        
    except Exception as e:
        print(f"❌ Error scoring with sklearn decision tree: {str(e)}")
        return np.zeros(len(data))

def create_comprehensive_scores(data):
    """
    Create comprehensive scoring results combining all models.
    
    Args:
        data (pd.DataFrame): Input data
        
    Returns:
        pd.DataFrame: Comprehensive scoring results
    """
    print("Creating comprehensive model scores...")
    
    try:
        # Load saved models
        models = load_saved_models()
        
        results = data.copy()
        
        # Score with tree_model.sas logic
        tree_results = score_with_decision_tree(data)
        results['tree_sas_probability'] = tree_results['P_default_flag1']
        results['tree_sas_node'] = tree_results['_Node_']
        results['tree_sas_leaf'] = tree_results['_Leaf_']
        
        # Score with sklearn models if available
        if models:
            if 'logistic' in models:
                results['logistic_sklearn_probability'] = score_with_logistic_regression(data, models)
            
            if 'decision_tree' in models:
                results['tree_sklearn_probability'] = score_with_sklearn_decision_tree(data, models)
            
            if 'calibrated' in models:
                # Use calibrated predictions if available
                cal_results = models['calibrated']
                if 'cal_val_proba' in cal_results:
                    # This would need to be recalculated for new data
                    pass
        
        # Create ensemble prediction (average of available models)
        prediction_cols = [col for col in results.columns if col.endswith('_probability')]
        if prediction_cols:
            results['ensemble_probability'] = results[prediction_cols].mean(axis=1)
        
        print("✓ Comprehensive scoring completed")
        return results
        
    except Exception as e:
        print(f"❌ Error creating comprehensive scores: {str(e)}")
        return data

def validate_scoring_functions():
    """
    Validate that scoring functions produce consistent results.
    """
    print("Validating scoring functions...")
    
    try:
        # Create test data
        test_data = pd.DataFrame({
            'credit_score': [650, 450, 720, 590],
            'total_risk_flags': [1, 3, 0, 2],
            'monthly_income': [5000, -1000, 3000, 2000],
            'debt_to_income_ratio': [0.3, 3.0, -0.5, 1.5],
            'emp_unemployed': [0, 1, 0, 0],
            'credit_utilization': [0.5, -0.8, 0.2, 0.6]
        })
        
        # Test tree scoring
        tree_results = score_with_decision_tree(test_data)
        
        print("✓ Tree scoring validation passed")
        print(f"  Sample predictions: {tree_results['P_default_flag1'].tolist()}")
        
        # Test model loading
        models = load_saved_models()
        print(f"✓ Model loading validation passed ({len(models)} models loaded)")
        
        return True
        
    except Exception as e:
        print(f"❌ Scoring function validation failed: {str(e)}")
        return False

def main():
    """
    Main function for testing scoring functions.
    """
    print("=" * 60)
    print("MODEL SCORING FUNCTIONS - TESTING")
    print("=" * 60)
    
    # Validate scoring functions
    if validate_scoring_functions():
        print("\n✓ All scoring functions validated successfully")
    else:
        print("\n❌ Scoring function validation failed")
    
    print("\nScoring functions ready for use:")
    print("- score_with_decision_tree(): Replicates tree_model.sas logic")
    print("- score_with_logistic_regression(): Uses saved logistic model")
    print("- score_with_sklearn_decision_tree(): Uses saved decision tree model")
    print("- create_comprehensive_scores(): Combines all scoring methods")

if __name__ == "__main__":
    main()
